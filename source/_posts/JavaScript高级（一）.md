---
title: JavaScript高级Ⅰ（持续更新）
date: 2020-08-29 22:57:40
tags:
- JavaScript
---
在学习JavaScript高级的时候的一些笔记干货：

一、数据类型判断
typeof：
可判断的数据：undefined、数值（Number）、字符串（String）、布尔值（Boolean）、函数（Function）；
不可判断：null与Object、Function与Array；
instanceof：
可判断的数据：Object对象的具体类型（Function、Array等）；
"==="：undefined、null；
二、数据、内存与变量
数据：存储在内存中代表特定信息的事物，本质上是0101...，要点：
（1）特点：可传递、可运算：逻辑运算、算术运算、赋值、函数执行；
（2）内存中所有操作的目标：数据；
内存：内存条通电后产生的可存储数据的临时空间，要点：
（1）内存的产生和消亡：内存条（电路版）——>通电——>产生内存空间——>存储数据——>处理数据——>断电——>内存空间和数据都会消失；
（2）内存中的2个数据：内部存储的数据、地址值；
&#8195;&#8195;注意：在赋值时，只有对象赋值才会赋值内存地址，其他都是赋值数据值；
（3）内存分类：
&#8195;&#8195;栈：全局变量、局部变量；
&#8195;&#8195;堆：对象；
（4）JS引擎管理内存，要点：
&#8195;&#8195;1）内存生命周期：
&#8195;&#8195;&#8195;&#8195;分配小内存空间，得到它的使用权；
&#8195;&#8195;&#8195;&#8195;存储数据，可反复操作；
&#8195;&#8195;&#8195;&#8195;释放小内存空间（变量所对应的空间）；
&#8195;&#8195;2）释放内存：
&#8195;&#8195;&#8195;&#8195;局部变量：函数执行完后自动释放；
&#8195;&#8195;&#8195;&#8195;对象：成为垃圾对象——>垃圾回收器在某个时刻进行回收；
变量：可变化的量，要点：
（1）由变量名和函数名组成，变量名用来查找对应内存，变量值就是内存中保存的数据；
（2）每个变量都对应一小块内存；
（3）在JS调用函数时传递变量参数时，有两种理解：
&#8195;&#8195;1）都是值（基本值/地址值）传递；
&#8195;&#8195;2）可能是值传递，也可能是引用传递（传的是地址值）；
三者的关系：
内存用来存储数据的空间，变量是内存的标识；

三、对象
多个数据的封装体，用来保护多个数据的容器；要点：
（1）组成：
&#8195;&#8195;1）属性：属性名（本质上是字符串）和属性值（任意值）组成；
&#8195;&#8195;2）方法：一种特别的属性（属性值是函数）；
（2）如何访问对象内部的数据
&#8195;&#8195;1）对象名.属性名：编码简单但不通用；
&#8195;&#8195;2）对象名['属性名']:编码麻烦但通用；以下情况一定要使用这种访问形式的情况：
&#8195;&#8195;&#8195;&#8195;属性名中包含特殊字符，例如："-"、空格等；
&#8195;&#8195;&#8195;&#8195;属性名并不确定；

四、函数
实现特定功能的n条语句封装体，只有函数可执行，其他类型的封装体不能够执行；要点：
（1）使用函数原因：可以提高代码的复用率和便于读者之间的交流；
（2）可使用函数声明和表达式（var 变量名=function(){}）来定义函数；
（3）调用函数的方法：
&#8195;&#8195;1）直接调用；
&#8195;&#8195;2）通过对象调用；
&#8195;&#8195;3）new调用，语法：new 函数名()；
&#8195;&#8195;4）临时让函数变为对象的方法进行调用，语法：函数名.call/apply(对象名)；

五、回调函数
种类：
（1）dom事件回调；（this：发生事件的dom元素）
（2）定时器回调函数；（this：window）
（3）ajax请求回调函数；
（4）生命周期函数；

六、IIFE
立即调用函数表达式（(function(){})）：Immediately-Invoked Function Expression（匿名函数自调用）
作用：
（1）隐藏实现
（2）不会污染外部命名空间（全局环境）；
（3）主要用于编写JS模块；
关于；的使用，绝大多数情况下可不加；但是以下两种情况需要加：
（1）小括号开头的语句（匿名函数自调用）；
（2）中方括号开头的语句；

七、this
（1）任何函数本质上都是通过某个对象调用，若没有直接指定，对象则是window；
（2）所有函数内部都有一个变量this；
（3）this的值都是调用函数的当前对象；

八、原型对象
原型对象（prototype）：每个函数都有一个prototype属性，默认指向一个Object空对象（但Object不是）：要点：
（1）在定义函数时自动添加，默认值为一个空白Object对象；
（2）原型对象的属性是原型对象特有的；
（3）原型对象有一个属性constructor，指向原型对象；例如：Fn.prototype.constructor===；
（4）程序员只可以操作原型对象（ES6之前）；
（5）每个函数的实例对象都自动拥有原型中的属性；

九、显式原型与隐式原型
显式原型（prototype）：在定义函数时自动添加默认值为一个空白Object对象（但Object不是）；
隐式原型（&#95;&#95;proto&#95;&#95;）：创建对象时自动添加的默认值为构造函数的prototype属性值（保存的是prototype属性的地址值，此地址值指向空白Object对象）；
对象的隐式原型的值为其对应构造函数的显式原型的值，例如：
function Fun(){}   //在此代码执行时，还会执行的一条内部语句：this.prototype={}
var fun=new Fun()   //构造函数Fun()
console.log(fun.&#95;&#95;proto&#95;&#95;===Fun.prototype)   //输出结果为true
//为原型对象添加属性（一般添加方法，当然，其他也可）
Fun.prototype.testp=function (){}

十、关于原型链
原型链是对象根据显式原型对象/隐式原型对象到Object隐式原型对象（Object本身除外）的一条链，要点：
（1）读取对象的属性值时，会自动到原型链中查找；
（2）设置对象的属性值时，不会往原型链中查找，若当前对象中无此属性，直接添加此属性并设置；
（3）方法一般定义在原型中，属性一般通过构造函数定义在对象上

十一、instanceof判断
A instanceof B
若B函数的显式原型对象在A对象的原型链上则为true，否则为false

十二、变量声明提升与函数声明提升
变量声明提升：通过var定义（声明）的变量，在定义语句之前可访问到，值为undefined；
函数声明提升：通过function声明的函数，在之前可直接调用；
先执行变量提升再执行函数提升

十三、执行上下文
分为全局执行上下文与函数执行上下文
全局执行上下文：在执行全局代码前将window确定为全局执行上下文
对全局数据进行预处理：
（1）var定义的全局变量为undefined，添加为window属性；
（2）function声明的全局函数，添加为window的方法
（3）this赋值为window；
函数执行上下文：在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象；
对局部数据进行预处理：
（1）形参变量赋值为实参，添加为函数执行上下文对象的属性；
（2）arguments（伪数组）赋值为实参列表，添加为函数执行上下文对象的属性；
（3）var定义的局部变量赋值为undefined，添加为函数执行上下文对象的属性；
（4）function声明的函数，添加为函数执行上下文对象的方法；
（5）this赋值为调用函数的对象；

十四、执行上下文栈
在全局代码执行前，JS引擎会创建一个栈来存储管理所有执行上下文对象；
栈特点：后进先出；
栈的工作流程：
（1）在全局执行上下文对象（window）确定后，将其添加到栈中，全局执行上下文对象永远都是在栈的最底端；
（2）在函数执行上下文创建后，将其添加到栈中；
（3）在当前函数执行完后，将当前函数对应的对象从栈中移除，相当于出栈；
（4）当所有的代码执行结束后，栈中只剩下window；

十五、作用域
代码所在的区域，在编写代码时就确定，是静态的；
作用域分类：全局作用域、函数作用域
作用域作用：隔离变量，不同作用域下同名变量不冲突；
作用域与执行上下文的区别与联系：
区别：
（1）在全局作用域之外，每个函数都会创建自身的一个函数作用域，作用域在函数定义时就已经确定，并非在函数调用时确定；
（2）全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建的；
（3）函数执行上下文环境是在调用函数时，函数体代码执行之前创建的；
（4）作用域是静态的，只要函数定义好了就一直存在，不会再有变化；
（5）执行上下文对象是动态的，调用函数时创建，函数调用结束时上下文对象会自动释放；
联系：
（1）上下文对象是从属于所在的作用域；
（2）全局上下文对象对应与全局作用域；
（3）函数执行上下文对象对应于函数作用域；

十六、闭包
对闭包的理解
理解一：闭包是嵌套的内部函数；
理解二：包含被引用变量的对象；
闭包的产生：
当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量时，就产生了闭包；
闭包产生的条件：
（1）函数嵌套；
（2）内部函数引用了外部函数的数据；
（3）执行函数定义就会产生闭包（不需要调用内部函数）；
闭包执行次数：
仅取决于外部函数执行了几次；
闭包的作用：
（1）使用函数内部的变量在函数执行完后，仍然存在于内存中（函数执行完后，函数内部声明的局部变量一般不会存在，但是存在于闭包中才可能存在）；
（2）让函数外部可操作到函数内部的数据（在函数外部并不能访问操作函数内部的数据变量）；
闭包的生命周期：
（1）闭包产生：在嵌套内部函数定义执行完时就产生了（并不是调用内部函数）；
（2）闭包死亡：在嵌套的内部函数成为垃圾对象时，闭包死亡（一般把调用闭包的对象赋值为null）；
闭包的应用：
定义JS模块，JS模块要点：
（1）具有特定功能的js文件；
（2）将所有数据和功能都封装在一个函数内部；
（3）只向外暴露一个包含n个方法的对象或函数；
闭包缺点：
（1）函数执行完后，函数内部的局部变量没有释放，占用内存时间变长
（2）容易造成内存泄露；

十七、内存溢出与内存泄露
内存溢出：当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误
内存泄露：占用的内存没有及时释放；而内存泄露积累多了容易导致内存溢出；
常见的内存泄露：
（1）意外的全局变量；
（2）没有及时清理的计时器或回调函数；
（3）闭包；

十八、对象创建模式
1、Object构造函数模式
（1）创建方法：先创建空的object对象，在动态添加属性或方法；
（2）适用于初始时的对象内部函数不确定；
（3）潜在问题：代码量较多；
2、对象字面量模式
（1）创建方法：使用"{}"创建对象，同时指定属性或者方法；
（2）适用于初始时的对象内部数据是确定的；
（3）潜在问题：若创建多个对象，会有代码重复；
3、工厂函数模式
（1）创建方法：通过工厂函数（返回一个对象的函数）动态创建对象并返回；
（2）适用于需要创建多个对象；
（3）潜在问题：所创建的对象没有一个明确的对象，都是Object类型；
4、自定义构造函数模式
（1）创建方法：自定义构造函数，通过new创建对象；
（2）适用于需要创建多个类型确定的对象；
（3）潜在问题：创建的对象会存在相同的数据（主要是构造函数内的函数方法），造成浪费内存；
5、自定义构造函数+原型组合模式
（1）创建方法：自定义构造函数，属性在函数中初始化，方法添加到原型上（语法：构造函数名.prototype.函数名=function(){}）
（2）适用于需要创建多个确定类型的对象；

