---
title: JavaScript高级Ⅰ（持续更新）
date: 2020-08-29 22:57:40
tags:
- JavaScript
---
在学习JavaScript高级的时候的一些笔记干货：

一、数据类型判断
typeof：
可判断的数据：undefined、数值（Number）、字符串（String）、布尔值（Boolean）、函数（Function）；
不可判断：null与Object、Function与Array；
instanceof：
可判断的数据：Object对象的具体类型（Function、Array等）；
"==="：undefined、null；
二、数据、内存与变量
数据：存储在内存中代表特定信息的事物，本质上是0101...，要点：
（1）特点：可传递、可运算：逻辑运算、算术运算、赋值、函数执行；
（2）内存中所有操作的目标：数据；
内存：内存条通电后产生的可存储数据的临时空间，要点：
（1）内存的产生和消亡：内存条（电路版）——>通电——>产生内存空间——>存储数据——>处理数据——>断电——>内存空间和数据都会消失；
（2）内存中的2个数据：内部存储的数据、地址值；
&#8195;&#8195;注意：在赋值时，只有对象赋值才会赋值内存地址，其他都是赋值数据值；
（3）内存分类：
&#8195;&#8195;栈：全局变量、局部变量；
&#8195;&#8195;堆：对象；
（4）JS引擎管理内存，要点：
&#8195;&#8195;1）内存生命周期：
&#8195;&#8195;&#8195;&#8195;分配小内存空间，得到它的使用权；
&#8195;&#8195;&#8195;&#8195;存储数据，可反复操作；
&#8195;&#8195;&#8195;&#8195;释放小内存空间（变量所对应的空间）；
&#8195;&#8195;2）释放内存：
&#8195;&#8195;&#8195;&#8195;局部变量：函数执行完后自动释放；
&#8195;&#8195;&#8195;&#8195;对象：成为垃圾对象——>垃圾回收器在某个时刻进行回收；
变量：可变化的量，要点：
（1）由变量名和函数名组成，变量名用来查找对应内存，变量值就是内存中保存的数据；
（2）每个变量都对应一小块内存；
（3）在JS调用函数时传递变量参数时，有两种理解：
&#8195;&#8195;1）都是值（基本值/地址值）传递；
&#8195;&#8195;2）可能是值传递，也可能是引用传递（传的是地址值）；
三者的关系：
内存用来存储数据的空间，变量是内存的标识；

三、对象
多个数据的封装体，用来保护多个数据的容器；要点：
（1）组成：
&#8195;&#8195;1）属性：属性名（本质上是字符串）和属性值（任意值）组成；
&#8195;&#8195;2）方法：一种特别的属性（属性值是函数）；
（2）如何访问对象内部的数据
&#8195;&#8195;1）对象名.属性名：编码简单但不通用；
&#8195;&#8195;2）对象名['属性名']:编码麻烦但通用；以下情况一定要使用这种访问形式的情况：
&#8195;&#8195;&#8195;&#8195;属性名中包含特殊字符，例如："-"、空格等；
&#8195;&#8195;&#8195;&#8195;属性名并不确定；

四、函数
实现特定功能的n条语句封装体，只有函数可执行，其他类型的封装体不能够执行；要点：
（1）使用函数原因：可以提高代码的复用率和便于读者之间的交流；
（2）可使用函数声明和表达式（var 变量名=function(){}）来定义函数；
（3）调用函数的方法：
&#8195;&#8195;1）直接调用；
&#8195;&#8195;2）通过对象调用；
&#8195;&#8195;3）new调用，语法：new 函数名()；
&#8195;&#8195;4）临时让函数变为对象的方法进行调用，语法：函数名.call/apply(对象名)；

五、回调函数
种类：
（1）dom事件回调；（this：发生事件的dom元素）
（2）定时器回调函数；（this：window）
（3）ajax请求回调函数；
（4）生命周期函数；

六、IIFE
立即调用函数表达式（(function(){})）：Immediately-Invoked Function Expression（匿名函数自调用）
作用：
（1）隐藏实现
（2）不会污染外部命名空间（全局环境）；
（3）主要用于编写JS模块；
关于；的使用，绝大多数情况下可不加；但是以下两种情况需要加：
（1）小括号开头的语句（匿名函数自调用）；
（2）中方括号开头的语句；

七、this
（1）任何函数本质上都是通过某个对象调用，若没有直接指定，对象则是window；
（2）所有函数内部都有一个变量this；
（3）this的值都是调用函数的当前对象；

八、原型对象
原型对象（prototype）：每个函数都有一个prototype属性，默认指向一个Object空对象（但Object不是）：要点：
（1）在定义函数时自动添加，默认值为一个空白Object对象；
（2）原型对象的属性是原型对象特有的；
（3）原型对象有一个属性constructor，指向原型对象；例如：Fn.prototype.constructor===；
（4）程序员只可以操作原型对象（ES6之前）；
（5）每个函数的实例对象都自动拥有原型中的属性；

九、显式原型与隐式原型
显式原型（prototype）：在定义函数时自动添加默认值为一个空白Object对象（但Object不是）；
隐式原型（&#95;&#95;proto&#95;&#95;）：创建对象时自动添加的默认值为构造函数的prototype属性值（保存的是prototype属性的地址值，此地址值指向空白Object对象）；
对象的隐式原型的值为其对应构造函数的显式原型的值，例如：
function Fun(){}   //在此代码执行时，还会执行的一条内部语句：this.prototype={}
var fun=new Fun()   //构造函数Fun()
console.log(fun.&#95;&#95;proto&#95;&#95;===Fun.prototype)   //输出结果为true
//为原型对象添加属性（一般添加方法，当然，其他也可）
Fun.prototype.testp=function (){}

十、关于原型链
原型链是对象根据显式原型对象/隐式原型对象到Object隐式原型对象（Object本身除外）的一条链，要点：
（1）读取对象的属性值时，会自动到原型链中查找；
（2）设置对象的属性值时，不会往原型链中查找，若当前对象中无此属性，直接添加此属性并设置；
（3）方法一般定义在原型中，属性一般通过构造函数定义在对象上

十一、instanceof判断
A instanceof B
若B函数的显式原型对象在A对象的原型链上则为true，否则为false


