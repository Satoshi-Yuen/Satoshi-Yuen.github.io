---
title: JavaScript基础Ⅱ（持续更新）
date: 2020-08-08 22:50:36
tags:
- JavaScript
---
三十四、DOM
DOM（Document Object Model）：文档对象模型，JS通过DOM来对HTML文档进行操作，要点：；
（1）节点（Node）：构成HTML文档最基本的单元，节点类型：文档节点、元素节点、属性节点、文本节点；
（2）浏览器已经提供文档节点对象（document），是window属性，可在页面中直接使用，文档节点代表整个页面；
（3）通过元素对象的id获取HTML文档中的对象：document.getElementById("对象id名")；
（4）修改按钮的文字：JS中获取到的按钮对象名.innerHTML="文字"；
&#8195;&#8195;1）innerHTML：可获取到元素内部的html代码，但是对自结束标签的对象无意义；
&#8195;&#8195;2）innerText：与innerHTML类似，不同的是innerText会自动去除html标签；
（5）事件：文档或者浏览器窗口中发生的一些特定的交互瞬间，可以在事件对应的属性中设置一些JS代码，当事件被触发时，代码将会被执行；
（6）给一个对象绑定一个单击事件：
&#8195;&#8195;1）在script标签内，JS获取到的对象名.onclick=function(){}；
&#8195;&#8195;2）在对象所在的标签中使用onclick="函数名()"来绑定，函数代码在script标签中编写；
&#8195;&#8195;3）可以通过window对象的onload事件，定义在整个页面加载完后才触发的方法函数事件；
（7）获取元素节点方式：
&#8195;&#8195;通过document对象调用：
&#8195;&#8195;&#8195;&#8195;1）getElementById()：通过标签的id获取到一个元素节点对象；
&#8195;&#8195;&#8195;&#8195;2）getElementsByTagName()：通过标签名获取到一组元素节点对象；
&#8195;&#8195;&#8195;&#8195;3）getElementsByName()：通过name属性获取到一组元素节点对象；
&#8195;&#8195;获取元素节点的子元素节点：
&#8195;&#8195;&#8195;&#8195;1）getElementsByTagName()：通过元素节点调用getElementsByTagName，可以获取该元素节点特定name名的所有子元素节点；
&#8195;&#8195;&#8195;&#8195;2）childNodes：通过该元素节点特定name名的所有子元素节点的childNodes属性可以获取包括文本节点在内的所有节点，根据DOM标签标签间空白也会被当作成文本节点（仅支持IE8以上的浏览器）；
&#8195;&#8195;&#8195;&#8195;3）children：通过该元素节点特定name名的所有子元素节点的children属性可以获取当前元素的所有子元素（支持所有浏览器）；
&#8195;&#8195;&#8195;&#8195;4）firstNode：通过该元素节点特定name名的所有子元素节点的firstNode属性可以获取当前节点的第一个子节点（包括空白文本）；
&#8195;&#8195;&#8195;&#8195;5）firstfirstElementChild：通过该元素节点特定name名的所有子元素节点的firstfirstElementChild属性可以获取当前元素节点下的第一个子元素（仅支持IE8以上的浏览器）；
&#8195;&#8195;&#8195;&#8195;6）lastNode：通过该元素节点特定name名的所有子元素节点的lastNode属性可以获取当前节点的最后一个子节点（包括空白文本）；
&#8195;&#8195;获取父节点和兄弟节点：
&#8195;&#8195;&#8195;&#8195;1）parentNode：通过元素节点的parentNode属性可以获取到这个元素节点的父节点；
&#8195;&#8195;&#8195;&#8195;2）previousSibling：通过元素节点的previousSibling属性可以获取到这个元素节点的前一个兄弟结点（包括会获取到空白文档）；
&#8195;&#8195;&#8195;&#8195;3）previousElementSibling：通过元素节点的previousElementSibling属性可以获取到这个元素节点的前一个兄弟元素（不会获取到空白文档，此属性支持IE8以上的浏览器）；
&#8195;&#8195;&#8195;&#8195;4）nextSibling：通过元素节点的nextSibling属性可以获取到这个元素节点的后一个兄弟节点（包括会获取到空白文档）；
（8）其他的一些查询方式：
&#8195;&#8195;1）document.body：查询出标签body；
&#8195;&#8195;2）document.documentElement：查询出html根标签；
&#8195;&#8195;3）document.getElementsByClassName()：根据元素的class属性查询一组元素节点对象（仅支持IE8以上的浏览器）；
&#8195;&#8195;4）document.querySelector()：可根据一个CSS选择器来查询一个元素节点对象，该方法查询总是会返回唯一的一个元素，若满足条件的有多个，那么它仍然是只会返回第一个（需要一个选择器的字符串作为参数，仅支持IE8以上的浏览器）；
&#8195;&#8195;5）document.querySelectorAll()：可根据一个CSS选择器来查询元素节点对象，该方法会将所有符合条件的元素对象封装到一个数组当中并返回，即便只有一个元素也会封装到一个数组当中（需要一个选择器的字符串作为参数，支持IE8及以上的浏览器）；
（9）dom增加：dom的增加包括以下步骤：
&#8195;&#8195;1）元素节点对象的创建：document.createElement()：需要一个标签名作为参数，函数会根据标签名创建元素节点对象并且将创建好的对象作为返回值返回；
&#8195;&#8195;2）文本节点对象的创建：document.createTextNode()：需要一个文本内容作为参数，函数会根据文本内容创建文本对象并且会将新的节点返回；
&#8195;&#8195;3）将文本节点对象添加到元素节点对象中（文本节点是这个元素节点的子节点）：父节点（创建的元素节点对象）.appendChild(子节点（创建的文本节点对象）)，appendChild()：向一个父节点中添加一个新的子节点；
&#8195;&#8195;另外，appendChild是在父节点的最后添加，而要想在指定位置添加的话可采用：insertBefore()的方法，此方法可在指定子节点前插入新的子节点，语法：父节点.insertBefore(新节点，旧结点)；
（10）dom删除：可删除一个子节点，语法：父节点.removeChild(子节点)；
（11）dom修改：除了一般的innerHTML修改内容外，还可以使用指定的子节点替换已有的子节点已达到修改的效果，语法：父节点.replaceChild(新节点，旧节点)；
（12）注意点：点击超链接后，超链接默认会跳转页面，可使用return false取消默认行为；
（13）注意点：在for循环内为a标签绑定响应函数时，for循环会在页面加载完成后立即执行，而响应函数会在超链接被点击时才执行，当响应函数执行时，for循环已执行完毕；
（14）通过JS修改元素样式：语法：元素.style.样式名=样式值；
&#8195;&#8195;要点注意：
&#8195;&#8195;1）CSS样式中有"-"的名称在JS中是不合法的，例如：background-color，需要将这种样式名修改，修改规则：将"-"去掉并将"-"后的单词首字母大写；
&#8195;&#8195;2）通过style属性设置和读取的都是内联样式（具有较高的优先级）；
（15）获取当前元素正在显示的样式，两种方式获取：
&#8195;&#8195;第一种：元素.currentStyle.样式名（只支持IE浏览器）；
&#8195;&#8195;&#8195;&#8195;当元素样式没有设置width时，若使用该方法获取会获取到auto；
&#8195;&#8195;&#8195;&#8195;currentStyle读取到的样式是只读的，不能修改；
&#8195;&#8195;第二种：getComputedStyle(obj,name)（不支持IE8及以下），要点：
&#8195;&#8195;&#8195;&#8195;参数obj：要获取样式的元素；
&#8195;&#8195;&#8195;&#8195;参数name：可传递一个伪元素，一般传递null；
&#8195;&#8195;&#8195;&#8195;这是window的函数方法，可直接使用：
&#8195;&#8195;&#8195;&#8195;该方法会返回一个对象，对象中封装了当前元素对应的样式
&#8195;&#8195;&#8195;&#8195;当元素样式没有设置width时，若使用该方法获取会获取到一个当前窗口的准确值；
&#8195;&#8195;&#8195;&#8195;getComputedStyle函数方法读取到的样式是只读的，不能修改；
（16）常用的元素样式操作属性：
&#8195;&#8195;1）clientWidth：获取元素的可见宽度；
&#8195;&#8195;2）clientHeight：获取元素的可见高度；
&#8195;&#8195;&#8195;&#8195;要点注意：
&#8195;&#8195;&#8195;&#8195;以上两个属性的返回值是不带px的数值；
&#8195;&#8195;&#8195;&#8195;宽度、高度包括内容区、内边距(padding)；
&#8195;&#8195;&#8195;&#8195;获取到的宽度、高度数据都是只读；
&#8195;&#8195;3）offsetWidth：获取整合元素的宽度；
&#8195;&#8195;4）offsetHeight：获取整合元素的高度；
&#8195;&#8195;&#8195;&#8195;要点注意：
&#8195;&#8195;&#8195;&#8195;以上两个属性的返回值是不带px的数值；
&#8195;&#8195;&#8195;&#8195;宽度、高度包括内容区、内边距(padding)和边框；
&#8195;&#8195;&#8195;&#8195;获取到的宽度、高度数据都是只读；
&#8195;&#8195;5）offsetParent：获取当前元素的定位父元素（离当前元素最近的开启了定位的祖先元素）；
&#8195;&#8195;6）offsetLeft：当前元素相对于其定位元素的水平偏移量；
&#8195;&#8195;7）offsetTop：当前元素相对于其定位元素的垂直偏移量；
&#8195;&#8195;8）scrollWidth：获取元素整个滚动区的宽度；
&#8195;&#8195;9）scrollHeight：获取元素整个滚动区的高度；
&#8195;&#8195;10）scrollLeft：获取水平滚动条滚动的距离；
&#8195;&#8195;11）scrollTop：获取垂直滚动条滚动的距离；
&#8195;&#8195;当scrollHeight-scrollTop==clientHeight成立时，说明垂直滚动条已滚动到底；
&#8195;&#8195;当scrollWidth-scrollLeft==clientWidth成立时，说明水平滚动条已滚动到底；
&#8195;&#8195;另：onscroll：该事件会在元素的滚动条滚动时触发，一般用法：元素.onscroll=function(){}；
（17）事件对象：
当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递给响应函数；
在事件对象中封装了当前事件相关的一切信息，包括鼠标所在桌面的坐标、键盘按下的按键、鼠标滚动的方向等等；
相关要点：
&#8195;&#8195;1）clientX：获取鼠标指针的水平坐标；
&#8195;&#8195;2）clientY：获取鼠标指针的垂直坐标；
&#8195;&#8195;&#8195;&#8195;注意：
&#8195;&#8195;&#8195;&#8195;IE8及以下中，响应函数被触发时，浏览器不会传递事件对象，所以事件对象会作为window对象的属性保存，使用clientX的例子：window.参数名.clientX；
&#8195;&#8195;&#8195;&#8195;在设置浏览器桌面某物根据鼠标位置移动而移动时，由于鼠标的偏移量是根据浏览器窗口来设定，而div的偏移量是根据整个页面文档设定的，所以当浏览器窗口出现滚动条时，这个跟随鼠标移动的某物在加上水平偏移量时也要加上水平滚动条滚动的长度（scrollTop），垂直方向同理；另外，关于浏览器的滚动条，chrome浏览器认为滚动条是属于body的，而其他浏览器认为滚动条是属于html的，所以在获取scrollTop或者scrollLeft时分别使用body或者html获取；
&#8195;&#8195;3）pageX：获取鼠标相对于当前页面的水平坐标；
&#8195;&#8195;4）pageY：获取鼠标相对于当前页面的垂直坐标；
&#8195;&#8195;&#8195;&#8195;注意：
&#8195;&#8195;&#8195;&#8195;不支持IE8及以下的浏览器；
（18）事件的冒泡：事件的向上传导，当后代元素的事件被触发时，其祖先元素的相同事件也会被触发
&#8195;&#8195;取消冒泡：将 事件对象.cancelBubble 设置为true；
（19）事件的委派：将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，会一直冒泡给祖先元素，从而通过祖先元素的响应函数来处理事件（实质上是使用了事件的冒泡）；
&#8195;&#8195;事件对象的target属性表示触发事件的对象，可以通过这个事件对象的属性指定触发事件的对象；
（20）事件的绑定：简单来讲就是绑定触发函数，但是，对象.事件=函数 这种形式只能绑定一个响应函数，绑定多个函数的话会被覆盖，要点：
&#8195;&#8195;1）addEventListener()：通过元素的这个方法可以为元素绑定多个响应函数（不支持IE8及以下的浏览器），此函数被触发时，this对象为调用这个函数的绑定对象；
&#8195;&#8195;&#8195;&#8195;参数：
&#8195;&#8195;&#8195;&#8195;事件的字符串："click"；
&#8195;&#8195;&#8195;&#8195;回调函数，当事件触发时该函数会被调用；
&#8195;&#8195;&#8195;&#8195;一个布尔值：是否在捕捉阶段触发事件，一般填写false；
&#8195;&#8195;2）attachEvent()：通过元素的这个方法可以为元素绑定多个响应函数（支持IE浏览器，一般不支持其他浏览器），这个函数数是先执行后绑定的，所以越往后定义的函数就会越先执行，跟addEventListener()的执行顺序相反；
&#8195;&#8195;&#8195;&#8195;参数：
&#8195;&#8195;&#8195;&#8195;事件的字符串："onclick"；
&#8195;&#8195;&#8195;&#8195;回调函数，当事件触发时该函数会被调用；
&#8195;&#8195;&#8195;&#8195;注意：由于这个函数的回调函数的调用对象是window，即this对象为window，要想将this对象变为绑定事件的对象，需要如下操作：
&#8195;&#8195;&#8195;&#8195;将参数中的回调函数改为匿名函数function(){回调函数.call(绑定事件的对象)}；
（21）事件的传播：
&#8195;&#8195;三个阶段：
&#8195;&#8195;&#8195;&#8195;1）捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是并不会触发事件；
&#8195;&#8195;&#8195;&#8195;2）目标阶段：事件捕获到目标元素，捕获结束后开始在目标元素上触发事件；
&#8195;&#8195;&#8195;&#8195;3）冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件；
&#8195;&#8195;另外介绍3个关于鼠标的常用属性（可用于完成点击元素元素跟随鼠标移动而移动的效果）：
&#8195;&#8195;&#8195;&#8195;1）onmousedown：鼠标被按下；
&#8195;&#8195;&#8195;&#8195;2）onmousemove：鼠标跟随元素移动；
&#8195;&#8195;&#8195;&#8195;3）ommouseup：鼠标被松开；
（22）元素的setCapture()函数：元素调用此方法时，将会把下一次所有的鼠标按下相关的事件捕获到自身身上（仅支持IE，但火狐浏览器不会报错）；可再次对元素调用releaseCapture()函数来释放（停止）捕获；使用setCapture函数可以作出只拖拽页面某些部分的效果；
（23）滚轮事件：会根据鼠标滚轮滚动而发生的事件，要点：
&#8195;&#8195;元素的onmousewheel属性：会在滚轮滚动时触发，要点：
&#8195;&#8195;&#8195;&#8195;1）不支持火狐浏览器，但火狐中具有相同功能的DOMMouseScroll属性，在火狐浏览器中使用该属性来绑定滚轮事件，但需要通过元素的addEventListener()函数来绑定；
&#8195;&#8195;event.wheelDelta属性：通过调用事件对象的wheelDelta属性可以判断鼠标滚轮滚动的方向，要点：
&#8195;&#8195;&#8195;&#8195;1）滚动的方向：向上滚为正值，向下滚为负值（数值不需要关心）；
&#8195;&#8195;&#8195;&#8195;2）不支持火狐浏览器，在火狐浏览器中可以使用event.detail属性来获取鼠标滚轮滚动方向，向上滚为负值，向下滚为正值（数值不需要关心）；
（24）键盘事件：会根据键盘按下的按键而发生的事件，要点：
&#8195;&#8195;键盘事件一般会绑定给一些能获取焦点的对象（主要是input的对象）和文档对象（document）；
&#8195;&#8195;主要的使用属性：
&#8195;&#8195;&#8195;&#8195;onkeydown属性：某个键盘按键被按下；
&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;注意：在文本框中输入内容属于onkeydown属性的默认行为，取消默认行为则不会出现在文本框中；
&#8195;&#8195;&#8195;&#8195;onkeyup属性：某个键盘按键被松开；
&#8195;&#8195;&#8195;&#8195;event.keyCode属性：可以判断是键盘的哪一个按键被按下，这个属性会返回按下的按键的字符编码；
&#8195;&#8195;&#8195;&#8195;event.altKey属性：判断alt键是否被按下（按下返回true，否则返回false）；
&#8195;&#8195;&#8195;&#8195;event.ctrlKey属性：判断ctrl键是否被按下（按下返回true，否则返回false）；
&#8195;&#8195;&#8195;&#8195;event.shiftKey属性：判断shift键是否被按下（按下返回true，否则返回false）；

三十五、BOM
BOM（Browser Object Model）：浏览器对象模型，BOM可通过JS来操作浏览器，主要是通过BOM提供的对象来完成操作；
（1）BOM对象：
&#8195;&#8195;Window：整个浏览器的窗口，同时window也是网页中的全局对象，可直接取之使用；
&#8195;&#8195;Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器，要点：；
&#8195;&#8195;&#8195;&#8195;由于历史原因，此对象大部分属性已不能够作为判断依据来识别浏览器，但一般还会使用userAgent属性来识别浏览器的信息，但是此属性对于IE11及以上的浏览器会失效，所以还可根据浏览器特有的对象来判断，例如：ActiveXObject，但要通过以下语法来判断：if("ActiveXObject" in window)；
&#8195;&#8195;Location：当前浏览器的信息，通过该对象可识别不同的浏览器，要点：
&#8195;&#8195;&#8195;&#8195;若直接将location属性改为一个完整地址或者是一个相对路径，则会自动跳转到该页面并且会生成相应的历史记录；
&#8195;&#8195;&#8195;&#8195;主要使用的函数：
&#8195;&#8195;&#8195;&#8195;assign()：用来跳转到其他的页面，作用和直接修改location的值一致（也会生成对应的历史记录）；
&#8195;&#8195;&#8195;&#8195;reload()：重新加载当前页面，作用和刷新按钮一致（传递一个参数true，会强制清空缓存刷新页面）；
&#8195;&#8195;&#8195;&#8195;replace()：可使用一个新的页面替换当前页面，调用完毕后会跳转页面但不会生成对应的历史记录；
&#8195;&#8195;History：代表当前浏览器的历史记录，可通过该对象来操作浏览器的历史记录，出于用户隐私，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只能在当次访问时有效；
&#8195;&#8195;&#8195;&#8195;length属性：可获取到当前访问的网页链接数量；
&#8195;&#8195;&#8195;&#8195;back()：可回退到上一个页面，作用和浏览器的回退按钮一样；
&#8195;&#8195;&#8195;&#8195;forward()：可跳转到下一个页面，作用和浏览器的前进按钮一样；
&#8195;&#8195;&#8195;&#8195;go()：可用于跳转到指定页面，需要一个整数作为参数传入；
&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;若传入的整数为正值则表示向前跳转整数个页面，若传入的整数为负值则表示向后跳转整数个页面；
&#8195;&#8195;Screen：代表用户的屏幕信息，通过该对象可获取到用户的显示器的相关信息；
（2）定时器
&#8195;&#8195;setInterval()：定时调用，可将一个函数每隔一段时间执行一次；
&#8195;&#8195;&#8195;&#8195;参数1：回调函数，该函数会每隔一段时间被调用一次；
&#8195;&#8195;&#8195;&#8195;参数2：每次调用间隔的时间，单位：毫秒；
&#8195;&#8195;该函数具有返回值，会返回一个Number类型的数据，用于作为定时器的唯一标识；
&#8195;&#8195;关闭定时器的函数：clearInterval()；
&#8195;&#8195;&#8195;&#8195;参数：一个定时器的标识；
&#8195;&#8195;setTimeout()：延时调用，一个函数不马上执行，而是隔一段时间后执行，并且只会执行一次；
&#8195;&#8195;&#8195;&#8195;参数1：回调函数，该函数会隔一段时间后被调用一次；
&#8195;&#8195;&#8195;&#8195;参数2：间隔的时间，单位：毫秒；
&#8195;&#8195;该函数具有返回值，会返回一个Number类型的数据，用于作为延时调用的唯一标识；
&#8195;&#8195;关闭延时调用的函数：clearTimeout()；
（3）类
在修改网页中元素的样式(CSS)时，可通过修改元素的style属性来实现，但是此方法不够好，因为每修改一个style样式，网页就需要重新渲染一次，这样会使得网页性能低下；通常会修改元素的class属性来实现，修改class属性，网页只会渲染一次，提高网页的性能，获取元素的class名：元素名.className；